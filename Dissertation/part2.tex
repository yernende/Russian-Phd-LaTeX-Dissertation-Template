\chapter{\textbf{Численные методы}}\label{ch:programming}
\section{\textbf{Задействованные математические библиотеки и пакеты}}\label{sec:programming/libraries}
Созданный в рамках данной работы программный комплекс реализован на двух языках. Ресурсоёмкие части реализованы на C++ и компилируются
в виде динамических библиотек, которые затем подключаются в код на Python с помощью библиотеки ctypes\cite{ctypes}. В коде на
Python реализована первичная обработка начальных данных, сведение воедино результатов вычислений и, наконец, вывод.

Одной из базовых задач при исполнении данной работы был подбор и освоение программных математических библиотек и
пакетов. Как уже отмечалось во введение, требованием к работе было использование свободного программного обеспечения,
тогда выбор становится очевиден.

В коде на Python это пакет NumPy\cite{harris2020array} и SciPy\cite{2020SciPy-NMeth}. Оба
написаны на С, С++ и Fortran и позволяют значительно ускорить вычисления, не теряя при этом в удобстве программирования
на Python. Numpy вводит особый тип данных, схожий с массивами, но поддерживающий исполнение различных математических операций.
Основное приложение NumPy "---программная реализация матриц, кроме того, с его помощью можно избежать чрезмерное употребление
циклов в коде, которые, сами по себе, в Python достаточно медленные. Функционал в SciPy достаточно обширен и включает в
себя алгоритмы численного интегрирования и дифференцирования, интерполяции, решения дифференциальных и систем линейных
уравнений, вычисления специальных функций. Оба пакета выпускаются под модифицированной лицензией
BSD\cite{numpy-license}\cite{scipy-license}, допускающей их свободное неограниченное использование, в том числе
встраивание в собственные проприетарные программы.

В коде на C++ это библиотека GNU Scientific Library\cite{galassi2018scientific}. Она написана на C совместимым с C++
образом, реализует работу с комплексными числами (впрочем, на практике удобней использовать те комплексные числа,
которые предоставляет сам С++) и разнообразные математические алгоритмы "---в основном всё то же, что уже перечислялось
выше для SciPy. GNU Scientific Library выпускается под лицензией GNU GPL третьей версии\cite{gsl-license} "---она
также допускает свободное использование, но создаёт требования при распространении программ, использующих данную
библиотеку, а именно, они также должны быть лицензированы под GNU GPL (либо под некоторыми другими совместимыми
лицензиями).

\section{\textbf{Геометрические векторы}}\label{sec:programming/vectors}
Для реализации формул, входящих в состав методов присоединённых плоских волн и рассеяных волн, было необходимо
реализовать работу с геометрическими векторами, записанными как в декартовых, так и сферических координатах, а также
их перевод из одной системы координат в другую. Соответствующий код на C++ был реализован в виде двух отдельных
классов: \texttt{coords\_cartesian} и \texttt{coords\_spherical}, как видно из названия, один позволяет записывать вектора
в декартовых координатах, а другой "---в сферических. С помощью функционала перегрузки операторов, предоставляемого C++,
реализовано сложение и вычитание представленных таким образом векторов, отдельные методы позволяют вычислять норму,
производить декартовое перемножение векторов, вычислять угол между векторами и переводить их из одной системы координат
в другую. Соответствующий код представлен в приложении~\cref{app:coordscpp}.

В той части кода, что написана на Python, соответствующий функционал реализован в виде единого класса \texttt{Vector},
который сразу хранит информацию как о декартовых координатах, так и о сферических "---см. приложение~\cref{app:vectorpy}.

\section{\textbf{Интегралы Гаунта}}\label{sec:programming/gaunt}
Интегралы Гаунта расчитываются по определению по формуле~\eqref{eq:gaunt}. Для этого с помощью средств SciPy
высчитывается сферическая функция\cite{scipy-spherical}, а затем она переводится в вещественную форму\cite{whittaker2014course}.
Далее следует численное интегрирование\cite{scipy-dblquad}, в результате которого получаем трёхмерную матрицу, индексами
которой являются упорядоченные пары $(l, m)$. Это матрица затем сохраняется в бинарный файл\cite{numpy-save} и может быть
сразу использована в дальнейшем без необходимости делать повторные расчёты.

\section{\textbf{Решение радиального уравнения}}\label{sec:programming/numerov}
Радиальное уравнение \eqref{eq:radialEquation} заменой
\begin{equation}\label{eq:radialFunctionChange}
  R_l(E, r) = \frac{P_{l E}(r)}{r}
\end{equation}

приводится к виду
\begin{equation}
  P_{l E}''(r)
  - \left(\frac{l \left(l + 1 \right)}{r^2} + V(r) - E\right) P_{l E}(r) = 0.
\end{equation}

Последнее может быть решено с помощью метода Нумерова. Полное описание метода можно найти в
книге~\cite{numerov}, остановимся лишь на его практической реализации.

Решение ДУ находится в виде последовательности точек. Из физических соображений, $P_{l E}(0) = 0$. Таким образом,
сразу известна первая точка решения. Вторая точка может быть задана произвольно, при этом $P_{l E}(r)$
будет найдена с точностью до постоянного множителя, который впоследствии вычисляется из условия нормировки. Если
заданы две точки, любые последующие могут быть высчитаны\cite{numerov-short} с помощью формулы
\begin{equation}
  P_{n} = \frac{(12-10f_{n-1}) P_{n-1}-f_{n-2}P_{n-2}}{f_{n}},
\end{equation}

где
\begin{equation}
f_n \equiv \left( 1 + \frac{h^2}{12}\left({\frac{l \left(l + 1 \right)}{r^2} + V(r) - E} \right) \right),
\end{equation}

а h "---шаг по аргументу функции.

Программный код, реализующий метод Нумерова, приведен в приложении~\cref{app:numerovcpp}. Для быстродействия код
написан на C++
и компилируется как динамическая библиотека, которая впоследствии может быть использована в программе на Python с
помощью библиотеки ctypes\cite{ctypes}.

Алгоритм можно упрощённо описать несколькими этапами:
\begin{enumerate}
    \item Построение интерполирующей функции для потенциала, переданного из программы на Python в виде
    последовательности точек.
    \item Решение ДУ для заданного потенциала, энергии и орбитального квантового числа методом Нумерова с малым шагом h
    "---при этом получается функция $P_{l E}(r)$, представленная большим числом точек.
    \item Построение интерполирующей функции для $P_{l E}(r)$.
    \item Интегрирование полученной интерполирующей функции, расчёт нормировочного коэффициента.
    \item Расчёт функции $R(E, r)$ как последовательности точек, согласно~\eqref{eq:radialFunctionChange}. При этом в
    первой точке получается неопределённость вида $\frac{0}{0}$, которая будет раскрыта в дальнейшем. Число точек,
    для экономии памяти и ускорения построения графиков, делается меньшим, чем изначально посчитанное "---в количестве,
    заданном программой на Python.
    \item Построение производной радиальной функции численными методами\cite{Fornberg1988GenerationOF} начиная с первой
    точки.
    \item Вычисление второй производной радиальной функции во второй точке.
    \item В допущении, что вторую производную радиальной функции при малых значениях аргумента можно считать постоянной,
    вычисление первой производной радиальной функции в нуле по формуле
    \begin{equation}
      R'_0 = R'_1 - R''_1 \tilde{h},
    \end{equation}

    где $\tilde{h}$ "---шаг по аргументу $R(E, r)$.

    \item Вычисление радиальной функции в нуле по формуле
    \begin{equation}
      R_0 = R_1 - R'_0 \tilde{h}.
    \end{equation}
\end{enumerate}

На рисунке~\cref{fig:radial-functions} приведены расчитанные таким образом радиальные функции на примере атома водорода
в различных состояниях. Потенциал при этом задаётся аналитически как
\begin{equation}
V(r) = -\frac{2}{r}.
\end{equation}

\begin{figure}[ht]
    \centerfloat{
        \ifdefmacro{\tikzsetnextfilename}{\tikzsetnextfilename{tikz_example_compiled}}{}% присваиваемое предкомпилированному pdf имя файла (не обязательно)
        \input{images/radial-functions.pgf}
    }
    \caption{Радиальные функции атома водорода в различных состояниях}\label{fig:radial-functions}
\end{figure}

Недостатком метода Нумерова является то, что его погрешность растёт при увеличении аргумента, и при большом его значении
радиальная функция может даже не сходиться к нулю. Альтернативным методом решения радиального уравнения является метод
Рунгe"--~Кутты. Для его использования необходимо переписать радиальное уравнение в виде системы обыкновенных
дифферинциальных уравнений
\begin{equation}\label{eq:RungeKuttaSolvableSystem}
  \begin{cases}
    P_{l E}'(r) = u_{l E}(r),\\
    u_{l E}'(r) = \left( \frac{l \left(l + 1 \right)}{r^2} + V(r) - E \right) P_{l E}(r).
  \end{cases}
\end{equation}

Реализация метода Рунге"--~Кутты для решения систем обыкновенных дифферинциальных уравнений есть как в библиотеке
GNU~Scientific~Library\cite{rk-gsl}, так
и в пакете SciPy\cite{rk-scipy}. Для начала решения нужно задать два начальных условия: значение $P_{l E}(r)$ в
нуле (это, как уже отмечалось, ноль), и значение производной $P_{l E}(r)$ в нуле с точностью до постоянного
множителя, выбор которого влияет лишь на нормировку полученного решения. Проблема состоит в том, что для некоторых
$P_{l E}(r)$ (например, у электрона в атоме водорода в состоянии с $E = 0.25, l = 1$) производная в нуле может быть равна
нулю, и домножение на постоянный множитель также даст ноль. Вместе с тем, при обеих нулевых начальных значениях данный
метод вернёт тривиальное решение "---нулевую функцию. Таким образом, один только метод Рунге"--~Кутты в общем случае непригоден для
решения радиального уравнения с произвольными параметрами. Однако, его можно использовать в связке с методом Нумерова,
если начинать считать не от нуля, а от некоторой следующей точки, так, чтобы хотя бы одно из начальных значений не было
нулевым (при этом все предшествующие точки должны быть посчитаны методом Нумерова). Таким образом можно получить
радиальную функцию с лучшим поведением при большом аргументе.

Следует, однако, отметить, что при слишком большом аргументе даже в случае с решением, полученным методом Рунге"--~Кутты,
радиальная функция, уже будучи весьма близка к нулю, внезапно начинает стремиться к бесконечности, поэтому её нужно
обрезать в точке последнего минимума.

\section{\textbf{Реализация метода присоединённых плоских волн}}\label{sec:programming/afw-method}
Метод присоединённых плоских волн реализован на языке Python. Код состоит из двух основных частей: модуля расчёта
матрицы (приложение~\cref{app:afwmatrixpy}) и входного файла (приложение~\cref{app:afwmainpy}), в котором реализован
параллельный (в нескольких потоках операционной системы) расчёт детерминанта модуля матрицы для различных значений
энергии из заданного интервала. Из специальных функций используются только сферические функции Бесселя "---они
расчитываются средствами SciPy\cite{scipy-spherical}. Также используются полиномы Лежандра, которые тоже считаются
с помощью SciPy\cite{scipy-legendre}.

На рисунке~\cref{fig:radial-functions} продемонстрирован расчёт зависимости детерминанта модуля матрицы от энергии на
примере атома водорода в основном состоянии (энергия представлена по модулю).
\begin{figure}[ht]
    \centerfloat{
        \ifdefmacro{\tikzsetnextfilename}{\tikzsetnextfilename{tikz_example_compiled}}{}% присваиваемое предкомпилированному pdf имя файла (не обязательно)
        \input{images/afw-plot.pgf}
    }
    \caption{Зависимость детерминанта модуля матрицы от энергии в методе присоединённых плоских волн}\label{fig:afw-plot}
\end{figure}

\section{\textbf{Реализация метода рассеянных волн}}\label{sec:programming/afw-method}
Пример кода на языке Python, реализующего метод рассеянных волн, продемонстрирован в приложении~\cref{app:swmainpy}.
В архитектурном и алгоритмическом плане он достаточно прост, остановится можно, разве что, на вычислении
модифицированных сферических функциях Ганкеля: дело в том, что их расчёт не входит в состав пакета SciPy, поэтому они
были реализованы самостоятельно по аналитическим формулам для значений $l \in [0, 2]$:
\begin{equation}
  k_0^{(1)}(x) = \frac{e^{-x}}{x}
\end{equation}

\begin{equation}
  k_1^{(1)}(x) = -\frac{e^{-x} (x + 1)}{x^2}
\end{equation}

\begin{equation}
  k_2^{(1)}(x) = \frac{e^{-x} (x^2 + 3x + 3)}{x^3}
\end{equation}

\begin{equation}
  \frac{d}{dx} k_0^{(1)}(x)= -\frac{e^{-x} (x + 1)}{x^2}
\end{equation}

\begin{equation}
  \frac{d}{dx}k_1^{(1)}(x) = \frac{e^{-x} (x (x + 2) + 2)}{x^3}
\end{equation}

\begin{equation}
  \frac{d}{dx}k_2^{(1)}(x) = -\frac{e^{-x} (x ((x + 4) + 9) + 9)}{x^4}
\end{equation}

Далее, для различных значений энергии в заданном диапазоне, вычисляется матрица, затем строится кривая зависимости
детерминанта матрицы от энергии "---согласно методу рассеянных волн, пересечения этой кривой с осью абсцисс должны дать
значения спектра заданной атомной системы.

\section{\textbf{Построение электронных плотностей}}\label{sec:programming/orbitals}
В рамках метода присоединённых плоских волн, после того, как были посчитаны спектры и коэфициенты разложения волновой
функции некоторой атомной структуры, можно построить электронные плотности, соответствующие различным спинам, по
следующим формулам:

\begin{equation}
  \rho^{+}(\mathbf{r}) = \sum_{n=1}^{n_{max}}{
    \sum_{l=0}^{2} {
      \sum_{m=-l}^{l} {
        (C_{nlm}^{+} Y_{lm}(\theta, \phi) R_{E(n) l}(r))^2,
      }
    }
  }
\end{equation}

\begin{equation}
  \rho^{-}(\mathbf{r}) = \sum_{n=1}^{n_{max}}{
    \sum_{l=0}^{2} {
      \sum_{m=-l}^{l} {
        (C_{nlm}^{-} Y_{lm}(\theta, \phi) R_{E(n) l}(r))^2,
      }
    }
  }
\end{equation}

где $n$ "---порядковый номер значения энергии в спектре.

Задача графического построения электронных плотностей, казалось бы, простая на бумаге, на практике сталкивается с
некоторыми сложностями. Для построения трёхмёрных изоповерхностей была использована библиотека
Mayavi\cite{ramachandran2011mayavi}. Она также написана на C++ и оформлена как пакет для Python, лицензия "---двойная,
либо MIT, либо GNU GPL третьей версии (то есть, пользователь библиотеки сам выбирает для себя лицензию из этих двух).
Библиотека Mayavi отвечает за рендеринг и платформонезависимый вывод интерактивного трёхмерного изображения, наша же
задача состоит в том, чтобы сгенерировать и передать ей трёхмерный массив из чисел с плавающей точкой. Математически
этот массив представляет собой дискретное скалярное поле в трёхмерном декартовом пространстве. Для построения
качественного изображения, как показала практика, размерность массива должна быть порядка 100 на 100 на 100 точек.
Таким образом, самой ресурсоёмкой частью программы является расчёт сферических функций. Для примера, если спектр состоит
из шести значений энергии, нужно сделать порядка пол миллиарда расчётов сферической функции. Код для выполнения
таких сложных вычислений написан на C++, с использованием возможностей библиотеки GNU Scientific Library и компилируется
как динамическая библиотека, точно так же, как делалось при расчёте радиальных функций.

Опишем в общих чертах алгоритм программы по выводу электронных орбиталей.
\begin{enumerate}
  \item Средствами Python (см. приложение~\cref{app:orbitalspy}) чтение с диска таблиц, в которые занесены значения
  потенциала и коэффициентов разложения волновых функций некоторой атомной системы. При этом, последние последовательно,
  в особом порядке, заносятся в одномерный массив, указатель на который затем будет передан в функцию, написанную на C++.
  \item Создаётся пустой массив "---то самое скалярное поле, которое нужно расчитать в коде на C++, однако не в
  трёхмерном виде, а в одномерном (при этом количество элементов в нём такое же, как было бы в соответствующем
  трёхмерном массиве). Такое решение выбрано по той причине, что при использовании динамической библиотеки проще всего
  передавать указатель на одномерный массив. В дальнейшем этот массив будет именоваться трёхмерной сеткой.
  \item На данном этапе управление переходит в динамическую библиотеку, написанную на С++
  (см. приложение~\cref{app:orbitalscpp}). Прежде всего проводится расчёт интерполирующей функции для потенциала,
  переданного из Python как последовательность точек "---так же, как было описано в \cref{sec:programming/numerov}.
  \item Далее происходит расчёт радиальных функций для всех значений энергии и $l$, которые пригодятся в дальнейшем.
  \item Для каждой точки трёхмерной сетки происходит расчёт соответствующего радиус-вектора (представленного с помощью
  класса \texttt{coords\_cartesian}) на основании её размера и максимального расчитываемого радиуса, заданного кодом
  на Python.
  \item Радиус-вектор переводится из декартовых координат в сферические.
  \item Проводится расчёт значения сферической функции для данной точки трёхмерной сетки.
  \item Проводится расчёт электронной плотности в данной точке
  \item Пункты 5"=8 повторяются до тех пор, пока трёхмерная сетка не будет полностью просчитана.
  \item Управление возвращается к коду на Python. Готовая трёхмерная сетка (напомним, что на самом деле это всё ещё
  одномерный массив, указатель на который был передан в код на C++) переводится\cite{numpy-reshape} в трёхмерный массив.
  \item Готовый трехмёрный массив чисел с плавающей точкой передаётся библиотеке Mayavi, которая и строит изоповерхности.
\end{enumerate}

На рисунке~\cref{fig:electron-densities} показан пример работы данной программы на примере углерода в кластере Al4C6,
который мы опишем далее.

\begin{figure}[ht]
    \begin{minipage}[b][][b]{0.49\linewidth}\centering
        \includegraphics[width=1\linewidth]{electron-1} \\ а)
    \end{minipage}
    \hfill
    \begin{minipage}[b][][b]{0.49\linewidth}\centering
        \includegraphics[width=1\linewidth]{electron-2} \\ б)
    \end{minipage}
    \caption{Электронная плотность, соответствующая <<отрицательному>> спину углерода в кластере Al4C6 в двух проекциях}
    \label{fig:electron-densities}
\end{figure}

\FloatBarrier
